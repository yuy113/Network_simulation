library(devtools)
#please comment the below code out if you already install the package-wActNet from github
install_github("yuy113/wActNet")
library(wActNet)
library(igraph)
#R package BioNet from BioConductor 
library(BioNet)
#Construct the graph from some real dataset
#set up the directory for the code
#change to your corresponding directory

setwd("/Users/yubingyao/Google Drive/Network analysis/R code/")

out_dir<-"/Users/yubingyao/Google Drive/Network analysis/R code/"

#download four datasets-ResponseVector.txt,Data.txt,MatchedPairIndicator.txt,pvalue_Permutation.txt
#response dataset
dat.resp<-read.table("ResponseVector.txt")

#covariates dataset
dat.var<-read.table("Data.txt")

#pair group id
dat.pairid<-read.table("MatchedPairIndicator.txt")

pval.edge<-read.table("pvalue_Permutation.txt",head=T)


pval.edge.1<-pval.edge$pval

names(pval.edge.1)<-pval.edge$name
#download edge_score_func.R to the default folder directory
source("edge_score_func.R")
edge.score<-uniform.beta.edge.score(pval=pval.edge.1,fdr=0.1)
#P-value from conditional likelihood for paired case-control study
#Contruct the node scores from the functions in BioNet libraryd
dat.obs<-data.frame(dat.resp,dat.pairid,dat.var)
colnames(dat.obs)<-c("Response","Pair_id",colnames(dat.var))
library(survival)
pval.node<-c()
for(i in 3:dim(dat.obs)[2]){
  logit.v<-clogit(Response ~dat.obs[,i]  + strata(Pair_id), dat.obs)  
  pval.node<-c(pval.node,summary(logit.v)$logtest["pvalue"])
}
names(pval.node)<-colnames(dat.obs)[3:dim(dat.obs)[2]]


edge.scores<-edge.score[edge.score>-1]
#contruct the test network with the format-igraph based on the dataset of the covariates and edge scores
da.igraph.test<-induced.graph.data.frame(dat=dat.var,node.score=NA,edge.score=edge.scores,node.weight=NA,edge.weight=NA)
#get the node score based on the network and p.values of the nodes in the network
node.scores<-node.score(da.igraph=da.igraph.test,pval=pval.node,fdr=0.1)

network<-induced.graph.data.frame(dat=dat.var,node.score=NA,edge.score=edge.scores,node.weight=NA,edge.weight=NA)
V(network)$score<-node.scores


####################################################################################################
#functions used for simulated clustered network
make_noconnection_cluster1_cluster2<-function(g,cluster1.id,cluster2.id){
  
  
  #make sure no connecting edges between two clusters
  #input 1: g-the igraph class object with names of nodes defined as "Varid" index of nodes
  #with edges names defined by "Varid1-Varid2" where id1,id2 is the indices of two connecting nodes
  #ionput 2: cluster1.id-the 1st cluter index list in vector form
  #ionput 3: cluster2.id-the 2nd cluter index list in vector form
  
  #output:the new igraph class object with no connection edges across the two clusters
  
  condition.cluster1.cluster2<-function(x,cluster1.id,cluster2.id){
    
    
    ( (length(unique(intersect(x,cluster1.id)))==1) & (length(unique(intersect(x,cluster2.id)))==1) ) 
    
    
  }
  #ind.cluster2<-apply(get.edgelist(g,names=F),1,function(x){ ((length(unique(intersect(x,cluster1.id)))==1) & (length(unique(intersect(x,cluster2.id)))==1)) })
  
  
  
  ind.cluster1<-apply(get.edgelist(g,names=F),1,condition.cluster1.cluster2,cluster1.id=cluster1.id,cluster2.id=cluster2.id)
  
  
  if (sum(ind.cluster1) == 0 ){
    return(g)
  }
  if (sum(ind.cluster1) > 0 ){
    
    new.edgelist.name<-get.edgelist(g,names=F)
    
    new.edgelist.name[ind.cluster1==1,]<-c(NA,NA)
    
    
    new.edgelist.name2<-na.omit(new.edgelist.name)
    
    new.edgelist.varname2<-t(apply(new.edgelist.name2,1,function(x){paste("Var",as.character(x),sep="")}))
    
    
    from.new.edge.list<-new.edgelist.varname2[,1]
    to.new.edge.list<-new.edgelist.varname2[,2]
    names.new.edge.list<-paste(from.new.edge.list,to.new.edge.list,sep="_")
    
    
    
    edge.dat<-data.frame(from= from.new.edge.list,to=to.new.edge.list,name= names.new.edge.list)
    
    nodes.dat<-data.frame(name=V(g)$name)
    
    interactome2 <- graph_from_data_frame(edge.dat, directed=F, vertices=nodes.dat)
    
    
    #interactome2 <- graph.edgelist(new.edgelist.varname2, T)
    
    
    #E(interactome2)$name<-paste(get.edgelist(interactome2,name=T)[,1],get.edgelist(interactome2,name=T)[,2],sep="_")
    
    
    return(interactome2)}
  
}






#subnetwork to induced subgraph from graph object considering both the vertices and edges,
#with remove.vertex=T,F; if True, then remove the vertices which is not in the edges, otherwise keep them
#vid-the names of the vertices in the graph
#eid-the names of the edges in the graph, with the format-Name(from_vertex)_Name(to_vertex)
#output:the subgraph containing only the vertices of vid and the edges

graph=g

subnetwork.e<-function(graph,vid,eid,remove.vertex=F){
  
  
  if(is.null(vid)){
    warning("No nodes for subnetwork")  
    break
  }
  
  
  
  
  if(!is.null(V(graph)$score)){
    node.scores<-V(graph)$score
    
    
    
    
    names(node.scores)<-V(graph)$name
    node.score.sub<-node.scores[vid]
    
  }
  if(!is.null(V(graph)$weight)){
    node.weight<-V(graph)$weight
    
    names(node.weight)<-V(graph)$name
    node.weight.sub<-node.weight[vid]
    
  }
  
  
  if(!is.null(E(graph)$weight)){
    edge.weight<-E(graph)$weight
    names(edge.weight)<-E(graph)$name}
  
  
  
  
  if(is.null(eid)){
    warning("No edges for subnetwork")  
    if(is.null(V(graph)$score) && is.null(V(graph)$weight) ){
      pos.nodes.dat<-data.frame(name=vid)}
    
    if(is.null(V(graph)$score) && !is.null(V(graph)$weight) ){
      pos.nodes.dat<-data.frame(name=vid,weight= node.weight.sub)} 
    
    if(!is.null(V(graph)$score) && is.null(V(graph)$weight) ){
      pos.nodes.dat<-data.frame(name=vid,score= node.score.sub)}
    g <- graph_from_data_frame(edge.pos.nodes.dat, directed=F, vertices=pos.nodes.dat)
    return(g)
    break
  }
  
  
  if(!is.null(E(graph)$score)){
    edge.scores<-E(graph)$score
    names(edge.scores)<-E(graph)$name
    edge.score.sub<-edge.scores[eid]
    
  }
  from.name.sub<-unlist(strsplit(E(graph)$name,"_"))[seq(1,2*length(E(graph)$name),by=2)]
  to.name.sub<-unlist(strsplit(E(graph)$name,"_"))[seq(2,2*length(E(graph)$name),by=2)]
  edge.name.sub<-as.matrix(cbind(from.name.sub,to.name.sub))
  if(dim( edge.name.sub)[1]>=1){
    edge.name.sub.node<-matrix(NA,nrow=dim(edge.name.sub)[1],ncol=dim(edge.name.sub)[2])
    
    
    
    for(i in 1:dim( edge.name.sub)[1]){
      if(length(intersect(vid,edge.name.sub[i,]))==2){
        edge.name.sub.node[i,] <-edge.name.sub[i,]
      }
      else
        edge.name.sub.node[i,] <-c(NA,NA)
      
    }
    edge.name.sub.node<-na.omit(edge.name.sub.node)
    from.name.edge.sub.nodes<-edge.name.sub.node[,1]
    to.name.edge.sub.nodes<-edge.name.sub.node[,2]
  }
  
  if( remove.vertex){
    if(length(unique(c( from.name.edge.sub.nodes, to.name.edge.sub.nodes)))<length(unique(vid))){
      vid<-unique(c( from.name.edge.sub.nodes, to.name.edge.sub.nodes))
      if ( dim(edge.name.sub.node)[1] >= 1){
        edge.name.sub.node2<-matrix(NA,nrow=dim(edge.name.sub.node)[1],ncol=dim(edge.name.sub.node)[2])
        
        for(i in 1:dim( edge.name.sub.node)[1]){
          if(length(intersect(vid,edge.name.sub.node[i,]))==2){
            edge.name.sub.node2[i,] <-edge.name.sub[i,]
          }
          else
            edge.name.sub.node2[i,] <-c(NA,NA)
          
        }
        edge.name.sub.node2<-na.omit(edge.name.sub.node2)
        from.name.edge.sub.nodes<-edge.name.sub.node2[,1]
        to.name.edge.sub.nodes<-edge.name.sub.node2[,2]
      }
    }
  }
  
  
  
  if(!is.null(V(graph)$score)){
    
    node.score.sub<-node.scores[vid]
    names(node.score.sub)<-vid
    
  }
  if(!is.null(V(graph)$weight)){
    
    node.weight.sub<-node.weight[vid]
    names(node.weight.sub)<-vid
  }
  
  
  
  
  
  
  
  
  names.edge.sub.nodes<-paste( from.name.edge.sub.nodes,to.name.edge.sub.nodes,sep="_")
  
  if(!is.null(E(graph)$score)){
    edge.score.sub.nodes<-edge.scores[names.edge.sub.nodes]
  }
  
  
  if(!is.null(E(graph)$weight)){
    edge.weight.sub.nodes<-edge.weight[names.edge.sub.nodes]}
  
  
  if(is.null(V(graph)$score) && is.null(V(graph)$weight) ){
    pos.nodes.dat<-data.frame(name=vid)}
  
  if(is.null(V(graph)$score) && !is.null(V(graph)$weight) ){
    pos.nodes.dat<-data.frame(name=vid,weight= node.weight.sub)} 
  
  if(!is.null(V(graph)$score) && is.null(V(graph)$weight) ){
    pos.nodes.dat<-data.frame(name=vid,score= node.score.sub)}
  
  if(!is.null(V(graph)$score) && !is.null(V(graph)$weight) ){
    pos.nodes.dat<-data.frame(name=vid,score= node.score.sub,weight=node.weight.sub)}
  
  if(!is.null(E(graph)$weight) && !is.null(E(graph)$score)){
    edge.pos.nodes.dat<-data.frame(from= from.name.edge.sub.nodes,to=to.name.edge.sub.nodes,
                                   score=edge.score.sub.nodes,name= names.edge.sub.nodes,weight=edge.weight.sub.nodes)}
  
  if(is.null(E(graph)$weight) && !is.null(E(graph)$score) ){
    edge.pos.nodes.dat<-data.frame(from= from.name.edge.sub.nodes,to=to.name.edge.sub.nodes,
                                   score=edge.score.sub.nodes,name= names.edge.sub.nodes)}
  
  
  if(is.null(E(graph)$weight) && is.null(E(graph)$score) ){
    edge.pos.nodes.dat<-data.frame(from= from.name.edge.sub.nodes,to=to.name.edge.sub.nodes,
                                   name= names.edge.sub.nodes)}
  
  
  if(!is.null(E(graph)$weight) && is.null(E(graph)$score) ){
    edge.pos.nodes.dat<-data.frame(from= from.name.edge.sub.nodes,to=to.name.edge.sub.nodes,
                                   weight=edge.weight.sub.nodes,name= names.edge.sub.nodes)}
  
  
  
  g <- graph_from_data_frame(edge.pos.nodes.dat, directed=F, vertices=pos.nodes.dat)
  return(g)}


#
#check any existing isolated nodes in some cluster
#if exisiting some existing isolated nodes, generate one edge between isolated nodes to some random  
#connected nodes within the cluster
#input 1: g-the igraph class object with names of nodes defined as "Varid" index of nodes
#with edges names defined by "Varid1-Varid2" where id1,id2 is the indices of two connecting nodes
#ionput 2: clusterid-the cluter index list in vector form
#output:the new igraph class object with no isolated nodes within the cluster
make_full_connected_cluster<-function(g,clusterid){
  library(igraph)
  
  g.edge.id<-cbind(as.numeric(unlist(strsplit(get.edgelist(g,names=T)[,1],"Var"))[seq(2,2*dim(get.edgelist(g,names=T))[1],2)]),
                   
                   as.numeric(unlist(strsplit(get.edgelist(g,names=T)[,2],"Var"))[seq(2,2*dim(get.edgelist(g,names=T))[1],2)]))
  
  
  ind.cluster1<-unlist(apply(g.edge.id,1,function(x) {length(intersect(x,clusterid))==2}))
  
  
  
  connected.nodes.cluster1<-unique(as.vector(g.edge.id[ind.cluster1==1,]))
  
  if(length(connected.nodes.cluster1)==0){
    
    
    #if no connected edges within all the nodes in the cluster  #make miminal number connections-cluster.size-1 to make all nodes  #connected in the cluster
    clusterid.new<-sample(clusterid,length(clusterid))
    new.cluster.edge<- t(sapply(1:(n.size-1),function(x){c(clusterid.new[x],clusterid.new[x+1])}))
    new.edgelist.cluster11<-t(apply(new.cluster.edge,1,function(x){paste("Var",x,sep="")}))
    #new.cluster.edge1.name<-paste(new.cluster.edge1[,1],new.cluster.edge1[,2],sep="_")
    
  } 
  
  if (length(connected.nodes.cluster1)==length(clusterid)){
    
    return(g)}
  
  
  else if(0 < length(connected.nodes.cluster1) & length(connected.nodes.cluster1) <length(clusterid)){
    
    #identity the subgraph with the nodes with clusterid
    g2<-subnetwork.e(g,vid=V(g)$name[clusterid],eid=E(g)$name)
    
    #identify the separated connected components within the subgraph
    conn.comp.graph <- decompose.graph(g2)
    
    
    #new.nodelist.cluster1<-setdiff(clusterid,connected.nodes.cluster1)
    new.edgelist.cluster11<-t(sapply(1:(length(conn.comp.graph)-1),function(x){c(sample(V(conn.comp.graph[[x]])$name,1)
                                                                                 , sample(V(conn.comp.graph[[x+1]])$name,1))}))
    
  }
  
  
  
  new.edgelist.not.cluster1<-get.edgelist(g,names=T)
  new.edgelist.cluster1<-rbind(new.edgelist.not.cluster1,new.edgelist.cluster11)
  
  from.new.edge.list<-new.edgelist.cluster1[,1]
  to.new.edge.list<-new.edgelist.cluster1[,2]
  names.new.edge.list<-paste(from.new.edge.list,to.new.edge.list,sep="_")
  
  
  
  edge.dat<-data.frame(from= from.new.edge.list,to=to.new.edge.list,name= names.new.edge.list)
  
  nodes.dat<-data.frame(name=V(g)$name)
  
  interactome2 <- graph_from_data_frame(edge.dat, directed=F, vertices=nodes.dat)
  
  
  # interactome2 <- graph.edgelist(new.edgelist.cluster1, F)
  # E(g)$name<-paste(get.edgelist(interactome2,name=T)[,1],get.edgelist(interactome2,name=T)[,2],sep="_")
  
  return(interactome2)
  
}








#generate the random graph using the number of nodes in the network
#p:the probability of connecting edges
#n.size-the size of positive scoring cluster,node scores in positive scoring clusters-uniform(0.1,1) or uniform(2,4)
#total 2 positive scoring clusters-within first one edge scores all positive-uniform(2,4) with high node score
#node scores in other nodes in the output random graph-uniform(-4,-2)
#edge scores in other edges in the output random graph-uniform(-4,1)
rand.posneg.network.new2<-function(network,p,n.size){
  library(igraph)
  library(BioNet)
  g <- erdos.renyi.game(vcount(network), p)
  V(g)$name<-paste("Var",as.character(1:vcount(network)),sep="")
  
  E(g)$name<-paste(get.edgelist(g,name=T)[,1],get.edgelist(g,name=T)[,2],sep="_")
  from<-get.edgelist(g,names=T)[,1]
  to<-get.edgelist(g,names=T)[,2]
  #construct the positive scoring cluster using multivariate normal distribution
  #n.size, the size of the positive scoring cluter-the number of the nodes in the cluster
  #p, the percentage of connecting edges 
  #make sure each node of two signal clusters is not isolated within the clusters 
  g<-make_full_connected_cluster(g,seq(1,n.size,1))
  g<-make_full_connected_cluster(g,seq((vcount(g)-n.size+1),vcount(g),1))
  
  
  
  #make sure the two clusters don't have direct connections
  g<-make_noconnection_cluster1_cluster2(g,seq(1,n.size,1),seq((vcount(g)-n.size+1),vcount(g),1))
  
  V(g)$score<-runif(vcount(g),min=-3,max=3)
  E(g)$score<-runif(ecount(g),min=-4,max=4)
  
  
  g.edge.id<-cbind(as.numeric(unlist(strsplit(get.edgelist(g,names=T)[,1],"Var"))[seq(2,2*dim(get.edgelist(g,names=T))[1],2)]),
                   
                   as.numeric(unlist(strsplit(get.edgelist(g,names=T)[,2],"Var"))[seq(2,2*dim(get.edgelist(g,names=T))[1],2)]))
  
  
  ind.cluster1<-unlist(apply(g.edge.id,1,function(x) return(sum(length(intersect(x,seq(1,n.size,1))))==2)))
  new.edgelist.cluster1<-get.edgelist(g,names=T)[ind.cluster1==1,]
  edge.name.cluster1<-paste(new.edgelist.cluster1[,1],new.edgelist.cluster1[,2],sep="_")
  
  
  
  n.edge1=length(edge.name.cluster1)
  score.edge1<-runif(n.edge1,min=2,max=4)
  names(score.edge1)<-edge.name.cluster1
  score.node.cluster1<-runif(n.size,min=0.1,max=2)
  names(score.node.cluster1)<-V(g)$name[1:n.size]
  V(g)$score[1:n.size]<-score.node.cluster1
  E(g)$score[ind.cluster1==1]<-score.edge1
  ##################################################################################
  
  
  #high node score,moderate edge score cluster
  ind.cluster4<-unlist(apply(g.edge.id,1,function(x) return(sum(length(intersect(x,seq((vcount(g)-n.size+1),vcount(g),1))))==2)))
  new.edgelist.cluster4<-get.edgelist(g,names=T)[ind.cluster4==1,]
  edge.name.cluster4<-paste(new.edgelist.cluster4[,1],new.edgelist.cluster4[,2],sep="_")
  
  n.edge4=length(edge.name.cluster4)
  score.edge4<-runif(n.edge4,min=0.1,max=2)
  names(score.edge4)<-edge.name.cluster4
  score.node.cluster4<-runif(n.size,min=2,max=4)
  names(score.node.cluster4)<-V(g)$name[seq((vcount(g)-n.size+1),vcount(g),1)]
  V(g)$score[seq((vcount(g)-n.size+1),vcount(g),1)]<-score.node.cluster4
  E(g)$score[ind.cluster4==1]<-score.edge4
  
  
  return(g)}





id.node.module<-function(g){
  
  if(!is.null(V(g)$name)){
    
    as.numeric(unlist(strsplit(V(g)$name,"r"))[seq(2,2*length(V(g)$name),2)])
    
  }
}
network<-network
n.sim=100
n.cluster=4
n.size=50
p=0.3
sim.test.pos.cluster2.new2<-function(network,n.size,p,n.sim,n.cluster){
  library(igraph)
  library(BioNet)
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  id.cluster2<-seq((vcount(network)-n.size+1),vcount(g),1)
  
  
  
  
  id.noise<-c((n.size+1):(vcount(network)-n.size))
  
  for (i in 1:n.sim){
    
    
    network.test<-rand.posneg.network.new2(network=network,n.size=n.size,p=p)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim11<-list(lst.nodenum.n,lst.nodenum.e)
 # save(result1.sim11,file="D:/Research project/Protein network analysis/Real data/R code/ERnew2_clustersize50_p03.Rdata")
  
  save(result1.sim11,file=paste(out_dir,"ERnew2_clustersize",as.character(n.size),"_p",as.character(p),".Rdata",sep=""))
  
  result1.sim11
  
}
  
  

#simulation scenario 1 in the paper-ER random graph model
#4 clusters with positive node scores and positive edge scores
#cluster size 50, connection probability-p=0.3
sim.result.er.clustersize50.p03.new2<-sim.test.pos.cluster2.new2(network,50,0.3,100,4)

#cluster size 50, connection probability-p=0.1
sim.result.er.clustersize50.p01.new2<-sim.test.pos.cluster2.new2(network,50,0.1,100,4)

#cluster size 20, connection probability-p=0.3
sim.result.er.clustersize20.p03.new2<-sim.test.pos.cluster2.new2(network,20,0.3,100,4)

#cluster size 20, connection probability-p=0.1
sim.result.er.clustersize20.p01.new2<-sim.test.pos.cluster2.new2(network,20,0.1,100,4)
  

#cluster size 10, connection probability-p=0.3
sim.result.er.clustersize10.p03.new2<-sim.test.pos.cluster2.new2(network,10,0.3,100,4)

#cluster size 10, connection probability-p=0.1
sim.result.er.clustersize10.p01.new2<-sim.test.pos.cluster2.new2(network,10,0.1,100,4)


  
  
  network<-network
  n.sim=100
  n.cluster=4
  n.size=50
  p=0.1
  library(igraph)
  library(BioNet)
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  id.cluster2<-seq((vcount(network)-n.size+1),vcount(g),1)
  
  
  
  
  id.noise<-c((n.size+1):(vcount(network)-n.size))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    network.test<-rand.posneg.network.new2(network=network,n.size=n.size,p=p)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim12<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim12,file=paste(out_dir,"ERnew2_clustersize",as.character(n.size),"_p",as.character(p),".Rdata",sep=""))
  
  
  
  network<-network
  n.sim=100
  n.cluster=2
  n.size=20
  p=0.1
  library(igraph)
  library(BioNet)
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  id.cluster2<-seq((vcount(network)-n.size+1),vcount(g),1)
  
  
  
  
  id.noise<-c((n.size+1):(vcount(network)-n.size))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    network.test<-rand.posneg.network.new2(network=network,n.size=n.size,p=p)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim22<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim22,file=paste(out_dir,"ERnew2_clustersize",as.character(n.size),"_p",as.character(p),".Rdata",sep=""))
  
  
  
  network<-network
  n.sim=100
  n.cluster=4
  n.size=20
  p=0.3
  library(igraph)
  library(BioNet)
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  id.cluster2<-seq((vcount(network)-n.size+1),vcount(g),1)
  
  
  
  
  id.noise<-c((n.size+1):(vcount(network)-n.size))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    network.test<-rand.posneg.network.new2(network=network,n.size=n.size,p=p)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim21<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim21,file=paste(out_dir,"ERnew2_clustersize",as.character(n.size),"_p",as.character(p),".Rdata",sep=""))
  
  
  
  
  network<-network
  n.sim=100
  n.cluster=4
  n.size=10
  p=0.1
  library(igraph)
  library(BioNet)
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  id.cluster2<-seq((vcount(network)-n.size+1),vcount(g),1)
  
  
  
  
  id.noise<-c((n.size+1):(vcount(network)-n.size))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    
    
    network.test<-rand.posneg.network.new2(network=network,n.size=n.size,p=p)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim32<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim32,file=paste(out_dir,"ERnew2_clustersize",as.character(n.size),"_p",as.character(p),".Rdata",sep=""))
  
  
  
  network<-network
  n.sim=100
  n.cluster=4
  n.size=10
  p=0.3
  library(igraph)
  library(BioNet)
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  id.cluster2<-seq((vcount(network)-n.size+1),vcount(g),1)
  
  
  
  
  id.noise<-c((n.size+1):(vcount(network)-n.size))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    
    
    network.test<-rand.posneg.network.new2(network=network,n.size=n.size,p=p)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim31<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim31,file=paste(out_dir,"ERnew2_clustersize",as.character(n.size),"_p",as.character(p),".Rdata",sep=""))
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  result1.sim21<-sim.test.pos.cluster1(network.test,n.size=50,p=0.3,n.sim=100)
  
  
  result1.sim22<-sim.test.pos.cluster1(network,n.size=50,p=0.1,n.sim=100)
  

  
  
  
  
  result1.sim11<-sim.test.pos.cluster1(network,n.size=10,p=0.3,n.sim=100)
  
  result1.sim12<-sim.test.pos.cluster1(network,n.size=10,p=0.1,n.sim=100)
  
  result1.sim31<-sim.test.pos.cluster1(network,n.size=20,p=0.3,n.sim=100)
  result1.sim32<-sim.test.pos.cluster1(network,n.size=20,p=0.1,n.sim=100)
  
  
  sim.result1.summary.32<-apply(result1.sim32,2,mean)
  sim.result1.summary.31<-apply(result1.sim31,2,mean)
  sim.result1.summary.21<-apply(result1.sim21,2,mean)
  sim.result1.summary.22<-apply(result1.sim22,2,mean)
  sim.result1.summary.12<-apply(result1.sim12,2,mean)
  sim.result1.summary.111<-apply(result1.sim11,2,mean)
  
  
  sim.result1.tot<-rbind(sim.result1.summary.11,sim.result1.summary.12,sim.result1.summary.22,sim.result1.summary.31,
                         sim.result1.summary.32)
  
  rownames(sim.result.tot)<-c("4cluster_size_10_p_0.3","4cluster_size_10_p_0.1",
                              "4cluster_size_20_p_0.1","4cluster_size_50_p_0.3",
                              "4cluster_size_50_p_0.1")
  write.table(sim.result.tot,"sim_result1_100.txt",row.names=T,col.names=T)
  
  
  
  
  
  
  
  #simulation scenario 2 with BA graph model
  #generate the Barabasi-Albert preferential attach/scale free graph using the number of nodes in the network
  #p:the probability of connecting edges
  #n.size-the size of positive scoring cluster3,node scores in positive scoring clusters-uniform(0.1,1) or uniform(2,4)

  ######################################################################################################################
  #simulation setup with 2 positive scoring clusters under Barabasi-Albert random graph model
  #Change the indices of 2 clusters where nodes with positive scores and edges with positive scores
  #BA random graph model change from densest to sparsest from node idex 1 to vcount(graph)
  #find the indices of the nodes to satisfy mininum connecting edges
  #for 77-with p approximately 77,floor(vcount(g)/4) to floor(vcount(g)/4)+n.cluster(20) all nodes connected
  #for 77-with p approximately 77,floor(vcount(g)/3) to floor(vcount(g)/3)+n.cluster(20) partial nodes connected
  #for 77-with p approximately 77,floor(vcount(g)/5) to floor(vcount(g)/5)+n.cluster(20) all nodes slightly dense connected
  #for 77-with p approximately 77,1 to n.cluster all nodes very densely connected
  randba.pos.network.new2<-function(network,m,power,n.size){
    library(igraph)
    library(BioNet)
    g <- barabasi.game(vcount(network),m=m,power=power,directed=F)
    V(g)$name<-paste("Var",as.character(1:vcount(network)),sep="")
    
    E(g)$name<-paste(get.edgelist(g,name=T)[,1],get.edgelist(g,name=T)[,2],sep="_")
    
    
    from<-get.edgelist(g,names=T)[,1]
    to<-get.edgelist(g,names=T)[,2]
    
    
    
    
    
    
    
    #make sure each node of two signal clusters is not isolated within the clusters 
    g<-make_full_connected_cluster(g,seq(1,n.size,1))
    n.start.cluster2<-floor(vcount(g)/2)
    cluster2.id<-seq(n.start.cluster2,n.start.cluster2+n.size-1,1)
    g<-make_full_connected_cluster(g,cluster2.id)
    #make sure the two clusters don't have direct connections
    g<-make_noconnection_cluster1_cluster2(g,seq(1,n.size,1),cluster2.id)
    
    V(g)$score<-runif(vcount(g),min=-3,max=3)
    E(g)$score<-runif(ecount(g),min=-4,max=4)
    
    
    g.edge.id<-cbind(as.numeric(unlist(strsplit(get.edgelist(g,names=T)[,1],"Var"))[seq(2,2*dim(get.edgelist(g,names=T))[1],2)]),
                     
                     as.numeric(unlist(strsplit(get.edgelist(g,names=T)[,2],"Var"))[seq(2,2*dim(get.edgelist(g,names=T))[1],2)]))
    
    
    ind.cluster1<-unlist(apply(g.edge.id,1,function(x) return(sum(length(intersect(x,seq(1,n.size,1))))==2)))
    new.edgelist.cluster1<-get.edgelist(g,names=T)[ind.cluster1==1,]
    edge.name.cluster1<-paste(new.edgelist.cluster1[,1],new.edgelist.cluster1[,2],sep="_")
    
    
    
    n.edge1=length(edge.name.cluster1)
    score.edge1<-runif(n.edge1,min=2,max=4)
    names(score.edge1)<-edge.name.cluster1
    score.node.cluster1<-runif(n.size,min=0.1,max=2)
    names(score.node.cluster1)<-V(g)$name[1:n.size]
    V(g)$score[1:n.size]<-score.node.cluster1
    E(g)$score[ind.cluster1==1]<-score.edge1
    
    
    
    
    ind.cluster2<-unlist(apply(g.edge.id,1,function(x) return(sum(length(intersect(x,cluster2.id)))==2)))
    new.edgelist.cluster2<-get.edgelist(g,names=T)[ind.cluster2==1,]
    edge.name.cluster2<-paste(new.edgelist.cluster2[,1],new.edgelist.cluster2[,2],sep="_")
    
    
    
    n.edge2=length(edge.name.cluster2)
    score.edge2<-runif(n.edge2,min=0.1,max=3)
    names(score.edge2)<-edge.name.cluster2
    score.node.cluster2<-runif(n.size,min=2,max=3)
    names(score.node.cluster2)<-V(g)$name[cluster2.id]
    V(g)$score[cluster2.id]<-score.node.cluster2
    E(g)$score[ind.cluster2==1]<-score.edge2
    
    
    return(g)}
  
  
sim.test.pos.cluster.ba.new2<-function(network,n.size,m,power,n.sim,n.cluster){
    
    lst.nodenum.n<-list()
    lst.nodenum.e<-list()
    id.cluster1<-seq(1,n.size,1)
    
    n.start.cluster2<-floor(vcount(network)/5)
    
    id.cluster2<-seq(n.start.cluster2,n.start.cluster2+n.size-1,1)
    
    
    id.noise<-c((n.size+1):(n.start.cluster2-1),((n.start.cluster2+n.size):vcount(network)))
    
    for (i in 1:n.sim){
      
      
      network.test<-randba.pos.network.new2(network=network,m=m,power=power,n.size=n.size)
      node.scores<-V(network.test)$score
      names(node.scores)<-V(network.test)$name
      
      edge.scores<-E(network.test)$score
      names(edge.scores)<-E(network.test)$name
      
      
      
      
      #find all posible optimized subnetworks by Dittrich node only method and our method
      modules.e<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
      
      E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
      
      E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
      
      
      edge.scores<-E(network.test)$score
      names(edge.scores)<-E(network.test)$name
      
      modules.n<-MultiModuleFind(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
      
      
      lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
      lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
      
      
      
      lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                      
                                                                      length(intersect(x,id.noise)))})
      
      lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                      
                                                                      length(intersect(x,id.noise)))})
      
      
    }
    result1.sim121<-list(lst.nodenum.n,lst.nodenum.e)
    save(result1.sim121,file=paste(out_dir,"BAnew2_clustersize",as.character(n.size),"_power",as.character(power*10),"m",as.character(m),".Rdata",sep=""))
    result1.sim121
    
  }
  
  
  
sim.result.ba.power15.m77.cluster50<-sim.test.pos.cluster.ba.new2(network,50,77,1.5,100,4)
  
sim.result.ba.power15.m24.cluster50<-sim.test.pos.cluster.ba.new2(network,50,24,1.5,100,4)

  

sim.result.ba.power15.m77.cluster20<-sim.test.pos.cluster.ba.new2(network,20,77,1.5,100,4)

sim.result.ba.power15.m24.cluster20<-sim.test.pos.cluster.ba.new2(network,20,24,1.5,100,4)  
  
  
  
  
  
  
  
  
  
  
  
  
  m=24
  power=1.5
  n.size=50
 
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  
  
  n.start.cluster2<-floor(vcount(network)/5)
  
  id.cluster2<-seq(n.start.cluster2,n.start.cluster2+n.size-1,1)
  
  
  id.noise<-c((n.size+1):(n.start.cluster2-1),((n.start.cluster2+n.size):vcount(g)))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    network.test<-randba.pos.network.new2(network=network,m=m,power=power,n.size=n.size)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim112<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim112,file=paste(out_dir,"BAnew2_clustersize",as.character(n.size),"_power",as.character(power*10),"m",as.character(m),".Rdata",sep=""))
  
  
  
  
  
  
  
  m=24
  power=1.5
  n.size=50

  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  
  
  n.start.cluster2<-floor(vcount(network)/5)
  
  id.cluster2<-seq(n.start.cluster2,n.start.cluster2+n.size-1,1)
  
  
  id.noise<-c((n.size+1):(n.start.cluster2-1),((n.start.cluster2+n.size):vcount(g)))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    network.test<-randba.pos.network.new2(network=network,m=m,power=power,n.size=n.size)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim111<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim111,file=paste(out_dir,"BAnew2_clustersize",as.character(n.size),"_power",as.character(power*10),"m",as.character(24),".Rdata",sep=""))
  
  
  
  
  
  
  
  m=24
  power=1.5
  n.size=20

  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  
  
  n.start.cluster2<-floor(vcount(network)/5)
  
  id.cluster2<-seq(n.start.cluster2,n.start.cluster2+n.size-1,1)
  
  
  id.noise<-c((n.size+1):(n.start.cluster2-1),((n.start.cluster2+n.size):vcount(g)))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    network.test<-randba.pos.network.new2(network=network,m=m,power=power,n.size=n.size)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim122<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim122,file=paste(out_dir,"BAnew2_clustersize",as.character(n.size),"_power",as.character(power*10),"m",as.character(77),".Rdata",sep=""))
  
  
  
  
  
  
  
  #simulation scenario 2
  #BA random graph model
  #2 positive soring clusters
  m=77
  power=1.5
  n.size=20
 
  lst.nodenum.n<-list()
  lst.nodenum.e<-list()
  id.cluster1<-seq(1,n.size,1)
  g<-network
  
  
  n.start.cluster2<-floor(vcount(network)/5)
  
  id.cluster2<-seq(n.start.cluster2,n.start.cluster2+n.size-1,1)
  
  
  id.noise<-c((n.size+1):(n.start.cluster2-1),((n.start.cluster2+n.size):vcount(g)))
  
  n.sim=100
  for (i in 1:n.sim){
    
    
    network.test<-randba.pos.network.new2(network=network,m=m,power=power,n.size=n.size)
    node.scores<-V(network.test)$score
    names(node.scores)<-V(network.test)$name
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    
    
    
    #find all posible optimized subnetworks by Dittrich node only method and our method
    modules.e<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
    
    E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
    
    E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
    
    
    edge.scores<-E(network.test)$score
    names(edge.scores)<-E(network.test)$name
    
    modules.n<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
    
    
    lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
    lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
    
    
    
    lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                    
                                                                    length(intersect(x,id.noise)))})
    
    
  }
  result1.sim121<-list(lst.nodenum.n,lst.nodenum.e)
  save(result1.sim121,file=paste(out_dir,"BAnew2_clustersize",as.character(n.size),"_power",as.character(power*10),"m",as.character(77),".Rdata",sep=""))
  
  
  
  
  #simulation scenario 1
  #BA random graph model
  #4 positive soring clusters
  
  m=77
  power=1.5
  n.size=20
  n.cluster=4
  n.sim=100
  n.cluster=4
  g<-network
  
sim.test.pos.cluster.ba.new<-function(network,n.size,m,power,n.sim,n.cluster){
    
    lst.nodenum.n<-list()
    lst.nodenum.e<-list()
    id.cluster1<-seq(1,n.size,1)
    
    n.start.cluster2<-floor(vcount(network)/5)
    
    id.cluster2<-seq(n.start.cluster2,n.start.cluster2+n.size-1,1)
    
    
    id.noise<-c((n.size+1):(n.start.cluster2-1),((n.start.cluster2+n.size):vcount(g)))
    
    for (i in 1:n.sim){
      
      
      network.test<-randba.pos.network41(network=network,m=m,power=power,n.size=n.size)
      node.scores<-V(network.test)$score
      names(node.scores)<-V(network.test)$name
      
      edge.scores<-E(network.test)$score
      names(edge.scores)<-E(network.test)$name
      
      
      
      
      #find all posible optimized subnetworks by Dittrich node only method and our method
      modules.e<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeEdge")
      
      E(network.test)$score<-E(network.test)$score[E(network.test)$score>0]
      
      E(network.test)$name<-E(network.test)$name[E(network.test)$score>0]
      
      
      edge.scores<-E(network.test)$score
      names(edge.scores)<-E(network.test)$name
      
      modules.n<-multimodule.find(network.test,node.scores,edge.scores,ncluster=n.cluster,method="NodeOnly")
      
      
      lst.modules.e.nodelist<-lapply(modules.e,id.node.module)
      lst.modules.n.nodelist<-lapply(modules.n,id.node.module)
      
      
      
      lst.nodenum.e[[i]]<-lapply(lst.modules.e.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                      
                                                                      length(intersect(x,id.noise)))})
      
      lst.nodenum.n[[i]]<-lapply(lst.modules.n.nodelist,function(x){c(length(x),length(intersect(x,id.cluster1)),length(intersect(x,id.cluster2)),
                                                                      
                                                                      length(intersect(x,id.noise)))})
      
      
    }
    result1.sim121<-list(lst.nodenum.n,lst.nodenum.e)
    save(result1.sim121,file=paste(out_dir,"BAnew1_clustersize",as.character(n.size),"_power",as.character(power*10),"m",as.character(24),".Rdata",sep=""))
    result1.sim121
    
}
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
